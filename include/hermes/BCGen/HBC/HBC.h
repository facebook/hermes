/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef HERMES_BCGEN_HBC_HBC_H
#define HERMES_BCGEN_HBC_HBC_H

#include "hermes/BCGen/HBC/BCProvider.h"
#include "hermes/BCGen/HBC/Bytecode.h"
#include "hermes/BCGen/HBC/FileAndSourceMapIdCache.h"
#include "hermes/Support/OptValue.h"
#include "hermes/Support/SHA1.h"
#include "hermes/Utils/Dumper.h"
#include "hermes/Utils/Options.h"

namespace llvh {
class raw_ostream;
} // namespace llvh

namespace hermes {
class SourceMapGenerator;
class Module;
class Function;

namespace hbc {

/// Flags passed to createBCProviderFromSrc to set parameters on execution.
struct CompileFlags {
  bool debug{false};
  bool lazy{false};

  /// Whether to error if the result is not a single function.
  bool requireSingleFunction{false};

  /// Eagerly compile files under this number of bytes, even when lazy.
  // Lazy compilation has significant per-module overhead, and is best applied
  // to large bundles with a lot of unused code. Eager compilation is more
  // efficient when compiling many small bundles with little unused code, such
  // as when the API user loads smaller chunks of JS code on demand.
  unsigned preemptiveFileCompilationThreshold{1 << 16};
  /// Eagerly compile functions under this number of bytes, even when lazy.
  unsigned preemptiveFunctionCompilationThreshold{160};

  bool strict{false};
  /// The value is optional; when it is set, the optimization setting is based
  /// on the value; when it is unset, it means the parser needs to automatically
  /// detect the 'use static builtin' directive and set the optimization setting
  /// accordingly.
  llvh::Optional<bool> staticBuiltins;

  /// Maximum number of instructions (in addition to parameter handling)
  /// that is allowed for inlining of small functions.
  unsigned inlineMaxSize{1};

  bool verifyIR{false};
  /// If set, the compiler emits async break check instructions.  These may be
  /// used for several purposes, for example, to enforce a time limit on
  /// execution.  Other flags may also cause these instructions to be emitted,
  /// for example debugging.
  bool emitAsyncBreakCheck{false};
  /// Include libhermes declarations when compiling the file. This is done in
  /// normal compilation, but not for eval().
  bool includeLibHermes{true};
  /// Enable generators.
  bool enableGenerator{true};
  /// Enable ES6 classes support
  bool enableES6Classes{false};
  /// Enable ES6 block scoping support
  bool enableES6BlockScoping{false};
  /// Define the output format of the generated bytecode. For instance, whether
  /// the bytecode is intended for execution or serialisation.
  OutputFormatKind format{Execute};
};

/// Callback for createBCProviderFromSrc to run the full optimization pipeline.
void fullOptimizationPipeline(Module &M);

/// Creates a BCProviderFromSrc by compiling the given JavaScript and
/// optionally optimizing it with the supplied callback.
/// \param buffer the JavaScript source to compile, encoded in utf-8. It is
///     required to have null termination ('\0') in the byte past the end,
///     in other words `assert(buffer.data()[buffer.size()] == 0)`.
/// \param topLevelFunctionName the name of the global function
///   "eval" for eval, "global" for ordinary scripts.
/// \param sourceURL this will be used as the "file name" of the buffer for
///     errors, stack traces, etc.
/// \param sourceMap optional input source map for \p buffer. It may be empty
///     if no source map is provided. If it is non-empty, the last byte must
///     be a null terminator.
/// \param compileFlags self explanatory
/// \param diagHandler handler for errors/warnings/notes.
/// \param diagContext opaque data that will be passed to diagHandler.
/// \param runOptimizationPasses if optimization is enabled in the settings
///     and this is non-null, invoke this callback with the IR module to
///     perform optimizations. This allows us to defer the decision of
///     whether to link all optimizations to the caller.
/// \param defaultBytecodeGenerationOptions the starting bytecode generation
///     options that will be used during the bytecode generation phase.
///     Some options will be overriden depending on other arguments passed in.
///
/// \return a BCProvider and an empty error, or a null BCProvider and an error
///     message (if diagHandler was provided, the error message is "error").
std::pair<std::unique_ptr<BCProvider>, std::string> createBCProviderFromSrc(
    std::unique_ptr<Buffer> buffer,
    llvh::StringRef sourceURL,
    llvh::StringRef sourceMap,
    const CompileFlags &compileFlags,
    llvh::StringRef topLevelFunctionName = "global",
    SourceErrorManager::DiagHandlerTy diagHandler = {},
    void *diagContext = nullptr,
    const std::function<void(Module &)> &runOptimizationPasses = {},
    const BytecodeGenerationOptions &defaultBytecodeGenerationOptions =
        BytecodeGenerationOptions::defaults());

/// Generates a BytecodeModule from a module \p M, and will return a unique_ptr
/// to the new module. The \p options parameter controls bytecode generation. If
/// \p sourceMap is not null, populate it with debug information from the
/// generated module.
/// \p baseBCProvider is the base bytecode used in delta optimizing mode;
/// when it is not null and optimization is turned on, we optimize for the delta
/// size between base and current bytecode.
/// \returns a pointer to the BytecodeModule.
std::unique_ptr<BytecodeModule> generateBytecodeModule(
    Module *M,
    Function *entryPoint,
    const BytecodeGenerationOptions &options,
    hermes::OptValue<uint32_t> segment = llvh::None,
    SourceMapGenerator *sourceMap = nullptr,
    std::unique_ptr<BCProviderBase> baseBCProvider = nullptr);

/// Generate bytecode for a lazy function and mutate the BytecodeModule
/// accordingly.
/// Called after parser/resolver/IRGen have run by lazy compilation.
/// \param bm the bytecode module to be modified.
/// \param M the IR module containing the lazy function.
/// \param lazyFunc the lazy function to be compiled.
/// \param lazyFuncID the ID of the lazy function.
/// \param options the bytecode generation options.
bool generateBytecodeFunctionLazy(
    BytecodeModule &bm,
    Module *M,
    Function *lazyFunc,
    uint32_t lazyFuncID,
    FileAndSourceMapIdCache &debugIdCache,
    const BytecodeGenerationOptions &options);

/// Generates a BytecodeModule from a module \p M, and will return a unique_ptr
/// to the new module. The \p options parameter controls bytecode generation.
/// \returns a pointer to the BytecodeModule.
std::unique_ptr<BytecodeModule> generateBytecodeModuleForEval(
    Module *M,
    Function *entryPoint,
    const BytecodeGenerationOptions &options);

/// Generate the bytecode for the lazy function by running the full compiler
/// pipeline without optimizations.
/// Mutates the underlying BytecodeModule of the BCProviderFromSrc and updates
/// all references stored in the BCProviderFromSrc.
/// Runs the compiler on a separate thread to avoid stack overflows, blocking
/// the current thread while doing so.
///
/// \param provider the BCProviderFromSrc owning the BytecodeModule.
///   Passed in as BCProvider to avoid BCProviderFromSrc dependencies in
///   CodeBlock (for simplicity).
/// \param funcID the ID of the lazy function to generate.
/// \return [success, errMsg] where errMsg is only populated when success is
///   false. The error message is stored in the lazy BytecodeFunction which
///   failed to compile.
///
/// NOTE: This function is exposed here for convenience, because there's no
/// better place to put it to access all the parts of the compiler.
/// It calls \c generateBytecodeFunctionLazy, but that function is also exposed
/// on principle because it's an actual entry point into the backend - this
/// function is really a driver for the entire compiler.
std::pair<bool, llvh::StringRef> compileLazyFunction(
    hbc::BCProvider *baseProvider,
    uint32_t funcID);

/// Convert line and column to a SMLoc.
/// \param provider the BCProvider to lookup in.
/// \param line 1-based line.
/// \param col 1-based column.
/// \return the SMLoc corresponding to the line/col, which may be invalid if
///   none was able to be found.
SMLoc findSMLocFromCoords(
    hbc::BCProvider *provider,
    uint32_t line,
    uint32_t col);

/// \pre the BytecodeFunction at funcID is lazy.
/// \param provider the BCProviderFromSrc owning the BytecodeModule.
///   Passed in as BCProvider to avoid BCProviderFromSrc dependencies in
///   CodeBlock (for simplicity).
/// \param funcID the ID of the lazy function.
/// \param loc the SMLoc to lookup.
/// \return whether the loc is contained in the lazy function.
bool coordsInLazyFunction(
    hbc::BCProvider *provider,
    uint32_t funcID,
    SMLoc loc);

/// Generate the bytecode for eval function by running the full compiler
/// pipeline without optimizations.
/// Creates a new BytecodeModule.
/// Mutates the IR Module (creates new Functions).
/// Creates a new SemContext as a child of the input provider's SemContext.
/// Runs the compiler on a separate thread to avoid stack overflows, blocking
/// the current thread while doing so.
///
/// \param src the JS source to be compiled.
/// \param provider the BCProviderFromSrc owning the BytecodeModule.
///   Passed in as BCProvider to avoid BCProviderFromSrc dependencies in
///   CodeBlock (for simplicity).
/// \param enclosingFuncID the ID of the function enclosing the new eval.
/// \return [success, errMsg] where errMsg is only populated when success is
///   false.
std::pair<std::unique_ptr<BCProvider>, std::string> compileEvalModule(
    std::unique_ptr<Buffer> src,
    hbc::BCProvider *provider,
    uint32_t enclosingFuncID,
    const CompileFlags &compileFlags);

/// \return a vector of the number of variables at each stack frame depth in
///   the function with the given ID, index 0 is the function itself.
std::vector<uint32_t> getVariableCounts(
    hbc::BCProvider *provider,
    uint32_t funcID);

/// \pre \p provider is a BCProviderFromSrc.
/// \return the name of the variable at frame depth \p depth and index \p
///   variableIndex for the function at \p funcID, index 0 is the function
///   itself.
llvh::StringRef getVariableNameAtDepth(
    hbc::BCProvider *provider,
    uint32_t funcID,
    uint32_t depth,
    uint32_t variableIndex);

} // namespace hbc
} // namespace hermes

#endif
