/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.hermes.intl;

import android.icu.util.ULocale;
import android.os.Build;
import android.text.TextUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;

class LanguageTagsGenerated {

    public static final boolean UsePreprocessedCLDRData = true;

    // Note:: This data is autogenerated using the tool whose source is kept at hermes/utils/IntlGen/IntlGen.java
    public static String[] regularGrandfatheredKeys = null;

    public static String[] regularGrandfatheredReplacements = null;

    public static String[] languageAliasKeys2 = null;

    public static String[] languageAliasReplacements2 = null;

    public static String[] languageAliasKeys3 = null;

    public static String[] languageAliasReplacements3 = null;

    public static String[] complexLanguageAliasKeys2 = null;

    public static String[] complexLanguageAliasReplacementsLanguage2 = null;

    public static String[] complexLanguageAliasReplacementsScript2 = null;

    public static String[] complexLanguageAliasReplacementsRegion2 = null;

    public static String[] complexLanguageAliasKeys3 = null;

    public static String[] complexLanguageAliasReplacementsLanguage3 = null;

    public static String[] complexLanguageAliasReplacementsScript3 = null;

    public static String[] complexLanguageAliasReplacementsRegion3 = null;

    public static String[] regionAliasKeys2 = null;

    public static String[] regionAliasReplacements2 = null;

    public static String[] regionAliasKeys3 = null;

    public static String[] regionAliasReplacements3 = null;

    static {

        if(UsePreprocessedCLDRData) {

            regularGrandfatheredKeys = new String[]{"art-lojban","cel-gaulish","i-default","i-enochian","i-mingo","zh-guoyu","zh-hakka","zh-min","zh-xiang"};

            regularGrandfatheredReplacements = new String[]{"jbo","xtg-x-cel-gaulish","en-x-i-default","und-x-i-enochian","see-x-i-mingo","zh","hak","nan-x-zh-min","hsn"};

            languageAliasKeys2 = new String[]{"bh", "in", "iw", "ji", "jw", "mo", "no", "tl", "tw"};

            languageAliasReplacements2 = new String[]{"bho", "id", "he", "yi", "jv", "ro", "nb", "fil", "ak"};

            complexLanguageAliasKeys2 = new String[]{"cnr"};

            complexLanguageAliasKeys2 = new String[]{"sh"};

            complexLanguageAliasReplacementsLanguage2 = new String[]{"sr"};

            complexLanguageAliasReplacementsScript2 = new String[]{"Latn"};

            complexLanguageAliasReplacementsRegion2 = new String[]{null};

            complexLanguageAliasKeys3 = new String[]{"cnr","drw","hbs","prs","swc","tnf"};

            complexLanguageAliasReplacementsLanguage3 = new String[]{"sr","fa","sr","fa","sw","fa"};

            complexLanguageAliasReplacementsScript3 = new String[]{null,null,"Latn",null,null,null};

            complexLanguageAliasReplacementsRegion3 = new String[]{"ME","af",null,"AF","CD","af"};

            languageAliasKeys3 = new String[]{"aam", "aar", "abk", "adp", "afr", "aju", "aka", "alb", "als", "amh", "ara", "arb", "arg", "arm", "asd", "asm", "aue", "ava", "ave", "aym", "ayr", "ayx", "aze", "azj", "bak", "bam", "baq", "bcc", "bcl", "bel", "ben", "bgm", "bih", "bis", "bjd", "bod", "bos", "bre", "bul", "bur", "bxk", "bxr", "cat", "ccq", "ces", "cha", "che", "chi", "chu", "chv", "cjr", "cka", "cld", "cmk", "cmn", "cor", "cos", "coy", "cqu", "cre", "cwd", "cym", "cze", "dan", "deu", "dgo", "dhd", "dik", "diq", "dit", "div", "drh", "dut", "dzo", "ekk", "ell", "emk", "eng", "epo", "esk", "est", "eus", "ewe", "fao", "fas", "fat", "fij", "fin", "fra", "fre", "fry", "fuc", "ful", "gav", "gaz", "gbo", "geo", "ger", "gfx", "ggn", "gla", "gle", "glg", "glv", "gno", "gre", "grn", "gti", "gug", "guj", "guv", "gya", "hat", "hau", "hdn", "hea", "heb", "her", "him", "hin", "hmo", "hrr", "hrv", "hun", "hye", "ibi", "ibo", "ice", "ido", "iii", "ike", "iku", "ile", "ilw", "ina", "ind", "ipk", "isl", "ita", "jav", "jeg", "jpn", "kal", "kan", "kas", "kat", "kau", "kaz", "kgc", "kgh", "khk", "khm", "kik", "kin", "kir", "kmr", "knc", "kng", "knn", "koj", "kom", "kon", "kor", "kpv", "krm", "ktr", "kua", "kur", "kvs", "kwq", "kxe", "kzj", "kzt", "lao", "lat", "lav", "lbk", "lii", "lim", "lin", "lit", "llo", "lmm", "ltz", "lub", "lug", "lvs", "mac", "mah", "mal", "mao", "mar", "may", "meg", "mhr", "mkd", "mlg", "mlt", "mnk", "mol", "mon", "mri", "msa", "mst", "mup", "mwj", "mya", "myd", "myt", "nad", "nau", "nav", "nbl", "ncp", "nde", "ndo", "nep", "nld", "nno", "nns", "nnx", "nob", "nor", "npi", "nts", "nya", "oci", "ojg", "oji", "ori", "orm", "ory", "oss", "oun", "pan", "pbu", "pcr", "per", "pes", "pli", "plt", "pmc", "pmu", "pnb", "pol", "por", "ppa", "ppr", "pry", "pus", "puz", "que", "quz", "rmy", "roh", "ron", "rum", "run", "rus", "sag", "san", "sca", "scc", "scr", "sin", "skk", "slk", "slo", "slv", "sme", "smo", "sna", "snd", "som", "sot", "spa", "spy", "sqi", "src", "srd", "srp", "ssw", "sun", "swa", "swe", "swh", "tah", "tam", "tat", "tdu", "tel", "tgk", "tgl", "tha", "thc", "thx", "tib", "tie", "tir", "tkk", "tlw", "tmp", "tne", "ton", "tsf", "tsn", "tso", "ttq", "tuk", "tur", "twi", "uig", "ukr", "umu", "uok", "urd", "uzb", "uzn", "ven", "vie", "vol", "wel", "wln", "wol", "xba", "xho", "xia", "xkh", "xpe", "xsj", "xsl", "ybd", "ydd", "yid", "yma", "ymt", "yor", "yos", "yuu", "zai", "zha", "zho", "zsm", "zul", "zyb"};

            languageAliasReplacements3 = new String[]{"aas", "aa", "ab", "dz", "af", "jrb", "ak", "sq", "sq", "am", "ar", "ar", "an", "hy", "snz", "as", "ktz", "av", "ae", "ay", "ay", "nun", "az", "az", "ba", "bm", "eu", "bal", "bik", "be", "bn", "bcg", "bho", "bi", "drl", "bo", "bs", "br", "bg", "my", "luy", "bua", "ca", "rki", "cs", "ch", "ce", "zh", "cu", "cv", "mom", "cmr", "syr", "xch", "zh", "kw", "co", "pij", "quh", "cr", "cr", "cy", "cs", "da", "de", "doi", "mwr", "din", "zza", "dif", "dv", "mn", "nl", "dz", "et", "el", "man", "en", "eo", "ik", "et", "eu", "ee", "fo", "fa", "ak", "fj", "fi", "fr", "fr", "fy", "ff", "ff", "dev", "om", "grb", "ka", "de", "vaj", "gvr", "gd", "ga", "gl", "gv", "gon", "el", "gn", "nyc", "gn", "gu", "duz", "gba", "ht", "ha", "hai", "hmn", "he", "hz", "srx", "hi", "ho", "jal", "hr", "hu", "hy", "opa", "ig", "is", "io", "ii", "iu", "iu", "ie", "gal", "ia", "id", "ik", "is", "it", "jv", "oyb", "ja", "kl", "kn", "ks", "ka", "kr", "kk", "tdf", "kml", "mn", "km", "ki", "rw", "ky", "ku", "kr", "kg", "kok", "kwv", "kv", "kg", "ko", "kv", "bmf", "dtp", "kj", "ku", "gdj", "yam", "tvd", "dtp", "dtp", "lo", "la", "lv", "bnc", "raq", "li", "ln", "lt", "ngt", "rmx", "lb", "lu", "lg", "lv", "mk", "mh", "ml", "mi", "mr", "ms", "cir", "chm", "mk", "mg", "mt", "man", "ro", "mn", "mi", "ms", "mry", "raj", "vaj", "my", "aog", "mry", "xny", "na", "nv", "nr", "kdz", "nd", "ng", "ne", "nl", "nn", "nbr", "ngv", "nb", "nb", "ne", "pij", "ny", "oc", "oj", "oj", "or", "om", "or", "os", "vaj", "pa", "ps", "adx", "fa", "fa", "pi", "mg", "huw", "phr", "lah", "pl", "pt", "bfy", "lcq", "prt", "ps", "pub", "qu", "qu", "rom", "rm", "ro", "ro", "rn", "ru", "sg", "sa", "hle", "sr", "hr", "si", "oyb", "sk", "sk", "sl", "se", "sm", "sn", "sd", "so", "st", "es", "kln", "sq", "sc", "sc", "sr", "ss", "su", "sw", "sv", "sw", "ty", "ta", "tt", "dtp", "te", "tg", "fil", "th", "tpo", "oyb", "bo", "ras", "ti", "twm", "weo", "tyj", "kak", "to", "taj", "tn", "ts", "tmh", "tk", "tr", "ak", "ug", "uk", "del", "ema", "ur", "uz", "uz", "ve", "vi", "vo", "cy", "wa", "wo", "cax", "xh", "acn", "waw", "kpe", "suj", "den", "rki", "yi", "yi", "lrr", "mtm", "yo", "zom", "yug", "zap", "za", "zh", "ms", "zu", "za"};

            regionAliasKeys2 = new String[]{"BU", "CT", "DD", "DY", "FX", "HV", "JT", "MI", "NH", "NQ", "PU", "PZ", "QU", "RH", "TP", "UK", "VD", "WK", "YD", "ZR"};

            regionAliasReplacements2 = new String[]{"MM", "KI", "DE", "BJ", "FR", "BF", "UM", "UM", "VU", "AQ", "UM", "PA", "EU", "ZW", "TL", "GB", "VN", "UM", "YE", "CD"};

            regionAliasKeys3 = new String[]{"004", "008", "010", "012", "016", "020", "024", "028", "031", "032", "036", "040", "044", "048", "050", "051", "052", "056", "060", "064", "068", "070", "072", "074", "076", "084", "086", "090", "092", "096", "100", "104", "108", "112", "116", "120", "124", "132", "136", "140", "144", "148", "152", "156", "158", "162", "166", "170", "174", "175", "178", "180", "184", "188", "191", "192", "196", "203", "204", "208", "212", "214", "218", "222", "226", "230", "231", "232", "233", "234", "238", "239", "242", "246", "248", "249", "250", "254", "258", "260", "262", "266", "268", "270", "275", "276", "278", "280", "288", "292", "296", "300", "304", "308", "312", "316", "320", "324", "328", "332", "334", "336", "340", "344", "348", "352", "356", "360", "364", "368", "372", "376", "380", "384", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "428", "430", "434", "438", "440", "442", "446", "450", "454", "458", "462", "466", "470", "474", "478", "480", "484", "492", "496", "498", "499", "500", "504", "508", "512", "516", "520", "524", "528", "531", "533", "534", "535", "540", "548", "554", "558", "562", "566", "570", "574", "578", "580", "581", "583", "584", "585", "586", "591", "598", "600", "604", "608", "612", "616", "620", "624", "626", "630", "634", "638", "642", "643", "646", "652", "654", "659", "660", "662", "663", "666", "670", "674", "678", "682", "686", "688", "690", "694", "702", "703", "704", "705", "706", "710", "716", "720", "724", "728", "729", "732", "736", "740", "744", "748", "752", "756", "760", "762", "764", "768", "772", "776", "780", "784", "788", "792", "795", "796", "798", "800", "804", "807", "818", "826", "831", "832", "833", "834", "840", "850", "854", "858", "860", "862", "876", "882", "886", "887", "894", "958", "959", "960", "962", "963", "964", "965", "966", "967", "968", "969", "970", "971", "972", "973", "974", "975", "976", "977", "978", "979", "980", "981", "982", "983", "984", "985", "986", "987", "988", "989", "990", "991", "992", "993", "994", "995", "996", "997", "998", "999", "AAA", "ABW", "AFG", "AGO", "AIA", "ALA", "ALB", "AND", "ARE", "ARG", "ARM", "ASC", "ASM", "ATA", "ATF", "ATG", "AUS", "AUT", "AZE", "BDI", "BEL", "BEN", "BES", "BFA", "BGD", "BGR", "BHR", "BHS", "BIH", "BLM", "BLR", "BLZ", "BMU", "BOL", "BRA", "BRB", "BRN", "BTN", "BUR", "BVT", "BWA", "CAF", "CAN", "CCK", "CHE", "CHL", "CHN", "CIV", "CMR", "COD", "COG", "COK", "COL", "COM", "CPT", "CPV", "CRI", "CUB", "CUW", "CXR", "CYM", "CYP", "CZE", "DDR", "DEU", "DGA", "DJI", "DMA", "DNK", "DOM", "DZA", "ECU", "EGY", "ERI", "ESH", "ESP", "EST", "ETH", "FIN", "FJI", "FLK", "FRA", "FRO", "FSM", "FXX", "GAB", "GBR", "GEO", "GGY", "GHA", "GIB", "GIN", "GLP", "GMB", "GNB", "GNQ", "GRC", "GRD", "GRL", "GTM", "GUF", "GUM", "GUY", "HKG", "HMD", "HND", "HRV", "HTI", "HUN", "IDN", "IMN", "IND", "IOT", "IRL", "IRN", "IRQ", "ISL", "ISR", "ITA", "JAM", "JEY", "JOR", "JPN", "KAZ", "KEN", "KGZ", "KHM", "KIR", "KNA", "KOR", "KWT", "LAO", "LBN", "LBR", "LBY", "LCA", "LIE", "LKA", "LSO", "LTU", "LUX", "LVA", "MAC", "MAF", "MAR", "MCO", "MDA", "MDG", "MDV", "MEX", "MHL", "MKD", "MLI", "MLT", "MMR", "MNE", "MNG", "MNP", "MOZ", "MRT", "MSR", "MTQ", "MUS", "MWI", "MYS", "MYT", "NAM", "NCL", "NER", "NFK", "NGA", "NIC", "NIU", "NLD", "NOR", "NPL", "NRU", "NZL", "OMN", "PAK", "PAN", "PCN", "PER", "PHL", "PLW", "PNG", "POL", "PRI", "PRK", "PRT", "PRY", "PSE", "PYF", "QAT", "QMM", "QNN", "QPP", "QQQ", "QRR", "QSS", "QTT", "QUU", "QVV", "QWW", "QXX", "QYY", "QZZ", "REU", "ROU", "RUS", "RWA", "SAU", "SDN", "SEN", "SGP", "SGS", "SHN", "SJM", "SLB", "SLE", "SLV", "SMR", "SOM", "SPM", "SRB", "SSD", "STP", "SUR", "SVK", "SVN", "SWE", "SWZ", "SXM", "SYC", "SYR", "TAA", "TCA", "TCD", "TGO", "THA", "TJK", "TKL", "TKM", "TLS", "TMP", "TON", "TTO", "TUN", "TUR", "TUV", "TWN", "TZA", "UGA", "UKR", "UMI", "URY", "USA", "UZB", "VAT", "VCT", "VEN", "VGB", "VIR", "VNM", "VUT", "WLF", "WSM", "XAA", "XBB", "XCC", "XDD", "XEE", "XFF", "XGG", "XHH", "XII", "XJJ", "XKK", "XLL", "XMM", "XNN", "XOO", "XPP", "XQQ", "XRR", "XSS", "XTT", "XUU", "XVV", "XWW", "XXX", "XYY", "XZZ", "YEM", "YMD", "ZAF", "ZAR", "ZMB", "ZWE", "ZZZ"};

            regionAliasReplacements3 = new String[]{"AF", "AL", "AQ", "DZ", "AS", "AD", "AO", "AG", "AZ", "AR", "AU", "AT", "BS", "BH", "BD", "AM", "BB", "BE", "BM", "BT", "BO", "BA", "BW", "BV", "BR", "BZ", "IO", "SB", "VG", "BN", "BG", "MM", "BI", "BY", "KH", "CM", "CA", "CV", "KY", "CF", "LK", "TD", "CL", "CN", "TW", "CX", "CC", "CO", "KM", "YT", "CG", "CD", "CK", "CR", "HR", "CU", "CY", "CZ", "BJ", "DK", "DM", "DO", "EC", "SV", "GQ", "ET", "ET", "ER", "EE", "FO", "FK", "GS", "FJ", "FI", "AX", "FR", "FR", "GF", "PF", "TF", "DJ", "GA", "GE", "GM", "PS", "DE", "DE", "DE", "GH", "GI", "KI", "GR", "GL", "GD", "GP", "GU", "GT", "GN", "GY", "HT", "HM", "VA", "HN", "HK", "HU", "IS", "IN", "ID", "IR", "IQ", "IE", "IL", "IT", "CI", "JM", "JP", "KZ", "JO", "KE", "KP", "KR", "KW", "KG", "LA", "LB", "LS", "LV", "LR", "LY", "LI", "LT", "LU", "MO", "MG", "MW", "MY", "MV", "ML", "MT", "MQ", "MR", "MU", "MX", "MC", "MN", "MD", "ME", "MS", "MA", "MZ", "OM", "NA", "NR", "NP", "NL", "CW", "AW", "SX", "BQ", "NC", "VU", "NZ", "NI", "NE", "NG", "NU", "NF", "NO", "MP", "UM", "FM", "MH", "PW", "PK", "PA", "PG", "PY", "PE", "PH", "PN", "PL", "PT", "GW", "TL", "PR", "QA", "RE", "RO", "RU", "RW", "BL", "SH", "KN", "AI", "LC", "MF", "PM", "VC", "SM", "ST", "SA", "SN", "RS", "SC", "SL", "SG", "SK", "VN", "SI", "SO", "ZA", "ZW", "YE", "ES", "SS", "SD", "EH", "SD", "SR", "SJ", "SZ", "SE", "CH", "SY", "TJ", "TH", "TG", "TK", "TO", "TT", "AE", "TN", "TR", "TM", "TC", "TV", "UG", "UA", "MK", "EG", "GB", "GG", "JE", "IM", "TZ", "US", "VI", "BF", "UY", "UZ", "VE", "WF", "WS", "YE", "YE", "ZM", "AA", "QM", "QN", "QP", "QQ", "QR", "QS", "QT", "EU", "QV", "QW", "QX", "QY", "QZ", "XA", "XB", "XC", "XD", "XE", "XF", "XG", "XH", "XI", "XJ", "XK", "XL", "XM", "XN", "XO", "XP", "XQ", "XR", "XS", "XT", "XU", "XV", "XW", "XX", "XY", "XZ", "ZZ", "AA", "AW", "AF", "AO", "AI", "AX", "AL", "AD", "AE", "AR", "AM", "AC", "AS", "AQ", "TF", "AG", "AU", "AT", "AZ", "BI", "BE", "BJ", "BQ", "BF", "BD", "BG", "BH", "BS", "BA", "BL", "BY", "BZ", "BM", "BO", "BR", "BB", "BN", "BT", "MM", "BV", "BW", "CF", "CA", "CC", "CH", "CL", "CN", "CI", "CM", "CD", "CG", "CK", "CO", "KM", "CP", "CV", "CR", "CU", "CW", "CX", "KY", "CY", "CZ", "DE", "DE", "DG", "DJ", "DM", "DK", "DO", "DZ", "EC", "EG", "ER", "EH", "ES", "EE", "ET", "FI", "FJ", "FK", "FR", "FO", "FM", "FR", "GA", "GB", "GE", "GG", "GH", "GI", "GN", "GP", "GM", "GW", "GQ", "GR", "GD", "GL", "GT", "GF", "GU", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IM", "IN", "IO", "IE", "IR", "IQ", "IS", "IL", "IT", "JM", "JE", "JO", "JP", "KZ", "KE", "KG", "KH", "KI", "KN", "KR", "KW", "LA", "LB", "LR", "LY", "LC", "LI", "LK", "LS", "LT", "LU", "LV", "MO", "MF", "MA", "MC", "MD", "MG", "MV", "MX", "MH", "MK", "ML", "MT", "MM", "ME", "MN", "MP", "MZ", "MR", "MS", "MQ", "MU", "MW", "MY", "YT", "NA", "NC", "NE", "NF", "NG", "NI", "NU", "NL", "NO", "NP", "NR", "NZ", "OM", "PK", "PA", "PN", "PE", "PH", "PW", "PG", "PL", "PR", "KP", "PT", "PY", "PS", "PF", "QA", "QM", "QN", "QP", "QQ", "QR", "QS", "QT", "EU", "QV", "QW", "QX", "QY", "QZ", "RE", "RO", "RU", "RW", "SA", "SD", "SN", "SG", "GS", "SH", "SJ", "SB", "SL", "SV", "SM", "SO", "PM", "RS", "SS", "ST", "SR", "SK", "SI", "SE", "SZ", "SX", "SC", "SY", "TA", "TC", "TD", "TG", "TH", "TJ", "TK", "TM", "TL", "TL", "TO", "TT", "TN", "TR", "TV", "TW", "TZ", "UG", "UA", "UM", "UY", "US", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XA", "XB", "XC", "XD", "XE", "XF", "XG", "XH", "XI", "XJ", "XK", "XL", "XM", "XN", "XO", "XP", "XQ", "XR", "XS", "XT", "XU", "XV", "XW", "XX", "XY", "XZ", "YE", "YE", "ZA", "CD", "ZM", "ZW", "ZZ"};
        }
    }
}

public class Intl {

    private static boolean isAlphaNum(String name, int start, int end, int min, int max) {
        assert (start >= 0 && end >= 0 && start <= name.length() && end <= name.length());

        return isAlphaNum(new StringBuffer(name), start, end, min, max);
    }


    private static boolean isAlphaNum(StringBuffer name, int start, int end, int min, int max) {
        assert (start >= 0 && end >= 0 && start <= name.length() && end <= name.length());

        int length = end-start + 1;
        if (length < min || length > max) {
            return false;
        }

        for (int idx=start; idx<=end; idx++) {
            char c = name.charAt(idx);
            if (!Character.isLetter(c) && !Character.isDigit(c)) {
                return false;
            }
        }

        return true;
    }

    private static boolean isAlpha(StringBuffer name, int start, int end, int min, int max) {
        assert (start >= 0 && end >= 0 && start <= name.length() && end <= name.length());

        int length = end-start + 1;
        if (length < min || length > max) {
            return false;
        }

        for (int idx=start; idx<=end; idx++) {
            char c = name.charAt(idx);
            if (!Character.isLetter(c)) {
                return false;
            }
        }

        return true;
    }

    private static boolean isDigit(StringBuffer name, int start, int end, int min, int max) {
        assert (start >= 0 && end >= 0 && start <= name.length() && end <= name.length());

        int length = end-start + 1;
        if (length < min || length > max) {
            return false;
        }

        for (int idx=start; idx<=end; idx++) {
            char c = name.charAt(idx);
            if (!Character.isDigit(c)) {
                return false;
            }
        }

        return true;
    }

    private static boolean isDigitAlphanum3(StringBuffer token, int start, int end) {
        return end - start + 1 == 4 && Character.isDigit(token.charAt(start)) && isAlphaNum(token, start + 1, end, 3, 3);
    }

    private static boolean isUnicodeLanguageSubtag(StringBuffer token, int start, int end) {
        // https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
        // = alpha{2,3} | alpha{5,8};
        return isAlpha(token, start, end, 2, 3) || isAlpha(token, start, end, 5, 8);
    }

    private static boolean isExtensionSingleton(StringBuffer token, int start, int end) {
        return isAlphaNum(token, start, end, 1, 1);
    }

    private static boolean isUnicodeScriptSubtag(StringBuffer token, int start, int end) {
        // https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
        // = alpha{4};
        return isAlpha(token, start, end, 4, 4);
    }

    private static boolean isUnicodeRegionSubtag(StringBuffer token, int start, int end) {
        // https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
        //= (alpha{2} | digit{3}) ;
        return isAlpha(token, start, end,2, 2) || isDigit(token, start, end,3, 3);
    }

    private static boolean isUnicodeVariantSubtag(StringBuffer token, int start, int end) {
        // https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
        // = (alphanum{5,8}
        // | digit alphanum{3}) ;
        return isAlphaNum(token, start, end, 5, 8) || isDigitAlphanum3(token,start, end);
    }

    enum TransformType {
        ToCapital,
        ToSmall,
        ToTitle,
        None
    };

    private static void transformAndCopyString(StringBuffer destination, StringBuffer source, int start, int end, TransformType transform) {
        for(int idx=start;idx<=end; idx++) {
            switch (transform) {
                case ToCapital:
                    destination.append(Character.toUpperCase(source.charAt(idx)));
                    break;
                case ToSmall:
                    destination.append(Character.toLowerCase(source.charAt(idx)));
                    break;
                case ToTitle:
                    if(idx==start)
                        destination.append(Character.toUpperCase((source.charAt(idx))));
                    else
                        destination.append(Character.toLowerCase(source.charAt(idx)));
                    break;
                default:
                    destination.append(source.charAt(idx));
            }
        }
    }

    private static boolean isSubtagSeparator(char c) {
        // Note: LDML allows both "_" and "-" unlike BCP47 : https://unicode.org/reports/tr35/#BCP_47_Conformance

        // return c  == '-' || c  == '_';
        // Note:: Even though LDML allows '_' as separator, our reference test data doesn't allow it !
        return c  == '-';
    }

    // Returns the next index
    private static boolean findNextSubtag(StringBuffer tag, int[] subTagTerminals) {

        if (subTagTerminals[1] == tag.length() - 1) {
            subTagTerminals[0] = tag.length();
            subTagTerminals[1] = tag.length();
            return true;
        }

        // Seek forward to the start of next subtag if not the first one.
        if(subTagTerminals[1] > subTagTerminals[0]) {
            char nextChar = tag.charAt(subTagTerminals[1] + 1) ;
            if(!isSubtagSeparator(nextChar)) {
                return false;
            }

            subTagTerminals[0] = subTagTerminals[1] + 2;
        }

        int seek = subTagTerminals[0];
        for (;seek < tag.length(); seek++) {
            char currentChar = tag.charAt(seek);
            if(isSubtagSeparator(currentChar)){
                break;
            }
        }

        subTagTerminals[1] = seek-1;

        if(subTagTerminals[1] >= subTagTerminals[0])
            return true;
        else
            return false;
    }

    private static void normalizeVariantAndAddToListSorted(StringBuffer languageTag, int currentTokenTerminalStart,
                                                           int currentTokenTerminalEnd, ArrayList<String> variantSubtagList) throws JSRangeErrorException{
        StringBuffer variantSubtagBuffer = new StringBuffer();
        for(int i=currentTokenTerminalStart; i<=currentTokenTerminalEnd; i++)
            variantSubtagBuffer.append(Character.toLowerCase(languageTag.charAt(i)));

        String variantSubtag = variantSubtagBuffer.toString();
        int position = Collections.binarySearch(variantSubtagList, variantSubtag);
        if(position < 0) {
            variantSubtagList.ensureCapacity(variantSubtagList.size() + 1); // todo:: check whether this is needed ?
            variantSubtagList.add(-1 * position - 1, variantSubtag);
        } else {
            throw new JSRangeErrorException("Duplicate variant");
        }
    }

    // https://tc39.es/ecma402/#sec-isstructurallyvalidlanguagetag
    // https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
    // Notes:: This is a highly compromised implementation of the specification.
    private static boolean checkStructuralValidityAndReturnParts(StringBuffer languageTag, StringBuffer languageSubtagBuffer,
                                                                 StringBuffer scriptSubtagBuffer, StringBuffer regionSubtagBuffer,
                                                                 ArrayList<String> variantSubtagList,
                                                                 StringBuffer extensionAndPrivateUseSequenceBuffer) throws JSRangeErrorException{
        assert(languageSubtagBuffer != null && languageSubtagBuffer.length() == 0);
        assert(scriptSubtagBuffer != null && scriptSubtagBuffer.length() == 0);
        assert(regionSubtagBuffer != null && regionSubtagBuffer.length() ==0);
        assert(extensionAndPrivateUseSequenceBuffer != null && extensionAndPrivateUseSequenceBuffer.length() == 0);
        assert(variantSubtagList != null && variantSubtagList.isEmpty());

        int currentTokenTerminals[] = new int[2];

        int languageTagLength = languageTag.length();

        if(!findNextSubtag(languageTag, currentTokenTerminals))
            return false;

        // We assume the languageId starts with language subtag, but LDML allows languageId starting with script subtag: https://unicode.org/reports/tr35/#BCP_47_Conformance
        if (!isUnicodeLanguageSubtag(languageTag, currentTokenTerminals[0], currentTokenTerminals[1]))
            return false;

        transformAndCopyString(languageSubtagBuffer, languageTag, currentTokenTerminals[0], currentTokenTerminals[1], TransformType.ToSmall);

        // Error while seeking next token
        if(!findNextSubtag(languageTag, currentTokenTerminals))
            return false; // Error while seeking next token

        if(currentTokenTerminals[0] == currentTokenTerminals[1] && currentTokenTerminals[0] == languageTag.length())
            return true; // No more tokens

        // Note: According to BCP47, the language subtag can be followed by extlang subtags which are sequence of upto 3 3-letter alphabetic codes.
        // But unicode LDML spec disallows it: https://unicode.org/reports/tr35/#BCP_47_Conformance

        // https://en.wikipedia.org/wiki/IETF_language_tag#Extensions
        // We don;t bother the rest of the tags.
        if (isExtensionSingleton(languageTag, currentTokenTerminals[0], currentTokenTerminals[1])) {
            transformAndCopyString(extensionAndPrivateUseSequenceBuffer, languageTag, currentTokenTerminals[0], languageTagLength - 1, TransformType.None);
            return true;
        }

        if (isUnicodeScriptSubtag(languageTag, currentTokenTerminals[0], currentTokenTerminals[1])) {
            transformAndCopyString(scriptSubtagBuffer, languageTag, currentTokenTerminals[0], currentTokenTerminals[1], TransformType.ToTitle);

            if(!findNextSubtag(languageTag, currentTokenTerminals))
                return false; // Error while seeking next token

            if(currentTokenTerminals[0] == currentTokenTerminals[1] && currentTokenTerminals[0] == languageTag.length())
                return true; // No more tokens
        }

        if (isUnicodeRegionSubtag(languageTag, currentTokenTerminals[0], currentTokenTerminals[1])) {
            transformAndCopyString(regionSubtagBuffer, languageTag, currentTokenTerminals[0], currentTokenTerminals[1], TransformType.ToCapital);

            if(!findNextSubtag(languageTag, currentTokenTerminals))
                return false;
        }

        do {

            if(currentTokenTerminals[0] == currentTokenTerminals[1] && currentTokenTerminals[0] == languageTag.length())
                return true; // No more tokens

            if (isExtensionSingleton(languageTag, currentTokenTerminals[0], currentTokenTerminals[1])) {
                transformAndCopyString(extensionAndPrivateUseSequenceBuffer, languageTag, currentTokenTerminals[0], languageTagLength - 1, TransformType.None);
                return true;
            }

            if (!isUnicodeVariantSubtag(languageTag, currentTokenTerminals[0], currentTokenTerminals[1]))
                return false;
            else {
                // Canonical form of variants is lower case
                normalizeVariantAndAddToListSorted(languageTag, currentTokenTerminals[0], currentTokenTerminals[1], variantSubtagList);
                // variantSubtagList.add(languageTag.substring(currentTokenTerminals[0], currentTokenTerminals[1] + 1).toLowerCase());
            }

            if(!findNextSubtag(languageTag, currentTokenTerminals))
                return false;

        } while(true);

        // Note: We are skiping the following as they can be expensive and doesn't add much value.
        // Other engines (V8, Chakra) also skip these validations as of today.
        // * does not include duplicate singleton subtags. *

        // return true;
    }

    private static void replaceLanguageSubtagIfNeeded(StringBuffer languageSubtagBuffer, StringBuffer scriptSubtagBuffer, StringBuffer regionSubtagBuffer) {

        String[] languageAliasKeys = null, languageAliasReplacements = null;
        String[] complexLanguageAliasKeys = null, complexLanguageAliasReplacementsLanguage = null, complexLanguageAliasReplacementsScript = null, complexLanguageAliasReplacementsRegion = null;

        if(languageSubtagBuffer.length() == 2) {
            languageAliasKeys = LanguageTagsGenerated.languageAliasKeys2;
            languageAliasReplacements = LanguageTagsGenerated.languageAliasReplacements2;

            complexLanguageAliasKeys = LanguageTagsGenerated.complexLanguageAliasKeys2;
            complexLanguageAliasReplacementsLanguage = LanguageTagsGenerated.complexLanguageAliasReplacementsLanguage2;
            complexLanguageAliasReplacementsScript = LanguageTagsGenerated.complexLanguageAliasReplacementsScript2;
            complexLanguageAliasReplacementsRegion = LanguageTagsGenerated.complexLanguageAliasReplacementsRegion2;
        } else {
            languageAliasKeys = LanguageTagsGenerated.languageAliasKeys3;
            languageAliasReplacements = LanguageTagsGenerated.languageAliasReplacements3;

            complexLanguageAliasKeys = LanguageTagsGenerated.complexLanguageAliasKeys3;
            complexLanguageAliasReplacementsLanguage = LanguageTagsGenerated.complexLanguageAliasReplacementsLanguage3;
            complexLanguageAliasReplacementsScript = LanguageTagsGenerated.complexLanguageAliasReplacementsScript3;
            complexLanguageAliasReplacementsRegion = LanguageTagsGenerated.complexLanguageAliasReplacementsRegion3;
        }

        int found = java.util.Arrays.binarySearch(languageAliasKeys, languageSubtagBuffer.toString());
        if(found >= 0) {
            languageSubtagBuffer.delete(0, languageSubtagBuffer.length());
            languageSubtagBuffer.append(languageAliasReplacements[found]);
        } else {
            // Try complex replacement
            found = java.util.Arrays.binarySearch(complexLanguageAliasKeys, languageSubtagBuffer.toString());
            if(found >= 0) {
                String languageSubtagReplacement = complexLanguageAliasReplacementsLanguage[found];
                String scriptSubtagReplacement = complexLanguageAliasReplacementsScript[found];
                String regionSubtagReplacement = complexLanguageAliasReplacementsRegion[found];

                assert(languageSubtagReplacement != null && languageSubtagReplacement.length() > 0);
                // Overwrite languageSubtag buffer
                languageSubtagBuffer.delete(0, languageSubtagBuffer.length());
                languageSubtagBuffer.append(languageSubtagReplacement);

                if(scriptSubtagBuffer.length() == 0 && scriptSubtagReplacement != null) {
                    scriptSubtagBuffer.append(scriptSubtagReplacement);
                }

                if(regionSubtagBuffer.length() == 0 && regionSubtagReplacement != null) {
                    regionSubtagBuffer.append(regionSubtagReplacement);
                }
            }
        }
    }

    private static String replaceRegionSubtagIfNeeded(StringBuffer regionSubtag) {
        if(regionSubtag.length() == 2) {
            int found = java.util.Arrays.binarySearch(LanguageTagsGenerated.regionAliasKeys2, regionSubtag.toString());
            if(found >= 0) {
                return LanguageTagsGenerated.regionAliasReplacements2[found];
            } else {
                return regionSubtag.toString();
            }
        } else {
            int found = java.util.Arrays.binarySearch(LanguageTagsGenerated.regionAliasKeys3, regionSubtag.toString());
            if(found >= 0) {
                return LanguageTagsGenerated.regionAliasReplacements3[found];
            } else {
                return regionSubtag.toString();
            }
        }

        // Note: We don't do complex region replacement as it is expensive to do.
    }

    private static String canonicalizeUnicodeLocaleIdUsingPlatformICU(String languageTag, StringBuffer languageSubtagBuffer, StringBuffer scriptSubtagBuffer,
                                                                      StringBuffer regionSubtagBuffer, ArrayList<String> variantSubtagList,
                                                                      StringBuffer extensionAndPrivateUseSequenceBuffer) throws JSRangeErrorException{
        // A quick comparative study with other implementations.
        // The canonical way to canonicalize a localeId string is to roundtrip it through the icu::Locale object using forLanguageTag/toLanguageTag functions.
        // V8 relies on icu4c implementation of the above functions, but augmented with private tables and code for handling special cases and error scenarios
        // https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/objects/intl-objects.cc
        // Also, note that Chromium applies a few patches (https://chromium.googlesource.com/chromium/deps/icu/+/refs/heads/master/patches/) over icu, which may also result in subtle behaviour differences.
        //
        // Firefox doesn't seem to rely on ICU much but custom implemented most code and tables
        // https://dxr.mozilla.org/mozilla-central/rev/c68fe15a81fc2dc9fc5765f3be2573519c09b6c1/js/src/builtin/intl/Locale.cpp#1233
        // Firefox has intentionally reimplemented them for performance as documented here:
        // https://dxr.mozilla.org/mozilla-central/rev/c68fe15a81fc2dc9fc5765f3be2573519c09b6c1/js/src/builtin/intl/LanguageTag.cpp#1034
        //
        // Chakra official releases links to Windows.Globalization libraries available in Windows,
        // But has an ICU variant which roundtrips the localId through icu::Locale as mentioned before with no other custom code around.
        //
        // Note:: icu4j is not a JNI wrapper around icu4c, but a reimplementation using Java.
        // Even though they have similar APIs, there are subtle deviations for e.g. in error handling.
        // Unlike the icu4c equivalents, the forLanguageTag in icu4j doesn't report any errors while parsing ..
        // For e.g. icu4c identifies bogus locids.. and report failure when part of the loclid can't be parsed. (https://github.com/unicode-org/icu/blob/79fac501010d63231c258dc0d4fb9a9e87ddb8d8/icu4c/source/common/locid.cpp#L816)
        // This results in our implementation a bit more leniant (i.e. not throwing RangeError for certain invalid inputs) campared to V8/Chakra
        // Both icu4c and icu4j implementations use private tables and mappings embedded in code for special cases such as deprecated and grandfathered  language code.
        // icu4c: https://github.com/unicode-org/icu/blob/9219c6ae038a3556dffca880e93d2f2ca00e685a/icu4c/source/common/uloc_tag.cpp#L103
        // icu4j: https://github.com/unicode-org/icu/blob/79fac501010d63231c258dc0d4fb9a9e87ddb8d8/icu4j/main/classes/core/src/com/ibm/icu/impl/locale/LanguageTag.java#L43
        // Android-icu4j: https://android.googlesource.com/platform/external/icu/+/refs/heads/master/android_icu4j/
        //
        // Clearly icu4c implementation has a few more private tables implementated, for e.g. the deprecated languages and regions. This results in subtle behavioural differences between our implemenation and say, V8.
        //
        // As of now, Firefox seems to be by far the most compliant engine out there.
        //
        // Our current implementation is directly over icu4j available with Android platform, augmented with some tables (grandfathered tags, simple language and region replacements etc.).
        //
        // Ref: https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/util/ULocale.html#forLanguageTag-java.lang.String-
        // Ref: https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1Locale.html#af76028775e37fd75a30209aaede551e2


        ULocale.Builder localeBuilder = new ULocale.Builder();

        replaceLanguageSubtagIfNeeded(languageSubtagBuffer, scriptSubtagBuffer, regionSubtagBuffer);
        localeBuilder.setLanguage(languageSubtagBuffer.toString());

        if(scriptSubtagBuffer.length() > 0) {
            localeBuilder.setScript(scriptSubtagBuffer.toString());
        }

        if(regionSubtagBuffer.length() > 0) {
            localeBuilder.setRegion(replaceRegionSubtagIfNeeded(regionSubtagBuffer));
        }

        if(!variantSubtagList.isEmpty()) {
            localeBuilder.setVariant(TextUtils.join("-", variantSubtagList));
        }

        try {

            if (extensionAndPrivateUseSequenceBuffer.length() > 0) {
                // TODO :: We have a relatively unoptimized implementation for parsing the extensions ..

                if (extensionAndPrivateUseSequenceBuffer.charAt(extensionAndPrivateUseSequenceBuffer.length() - 1) == '-') {
                    throw new JSRangeErrorException("Incomplete singleton");
                }

                String extensions[] = new String[26];
                String[] extensionTokens = extensionAndPrivateUseSequenceBuffer.toString().split("-");
                char currentSingleton = Character.MIN_VALUE;
                StringBuffer currentExtensionSequence = new StringBuffer();
                for (int tokenIdx = 0; tokenIdx < extensionTokens.length; tokenIdx++) {
                    String extensionToken = extensionTokens[tokenIdx];

                    if (extensionToken.length() == 1) {
                        char newSingleton = Character.toLowerCase(extensionToken.charAt(0));

                        if (currentSingleton != Character.MIN_VALUE && currentSingleton != 'x') {
                            if (extensions[currentSingleton - 'a'] != null) {
                                throw new JSRangeErrorException("Duplicate singleton");
                            }
                            if (currentExtensionSequence.length() == 0) {
                                throw new JSRangeErrorException("Empty singleton");
                            }
                            if (!isAlphaNum(currentExtensionSequence, 0, currentExtensionSequence.length() -1, 1, 8)) {
                                throw new JSRangeErrorException("Invalid singleton: " + languageTag);
                            }

                            extensions[currentSingleton - 'a'] = currentExtensionSequence.toString();
                        }

                        currentSingleton = newSingleton;
                        currentExtensionSequence.delete(0, currentExtensionSequence.length());

                        if (newSingleton == 'x') {
                            // Consume the rest of the tokens.
                            tokenIdx++;
                            while (tokenIdx < extensionTokens.length) {
                                extensionToken = extensionTokens[tokenIdx];

                                if (currentExtensionSequence.length() > 0)
                                    currentExtensionSequence.append('-');

                                if (!isAlphaNum(extensionToken, 0, extensionToken.length() - 1, 1, 8)) {
                                    throw new JSRangeErrorException("Invalid singleton: " + languageTag);
                                }

                                currentExtensionSequence.append(extensionToken.toLowerCase());
                                tokenIdx++;
                            }

                            if (extensions['x' - 'a'] != null) {
                                throw new JSRangeErrorException("Duplicate singleton");
                            }
                            if (currentExtensionSequence.length() == 0) {
                                throw new JSRangeErrorException("Empty singleton");
                            }

                            extensions['x' - 'a'] = currentExtensionSequence.toString();
                            break;
                        }
                    } else {
                        if (currentExtensionSequence.length() > 0)
                            currentExtensionSequence.append('-');

                        if (!isAlphaNum(extensionToken, 0, extensionToken.length() - 1, 1, 8)) {
                            throw new JSRangeErrorException("Invalid singleton: " + languageTag);
                        }

                        currentExtensionSequence.append(extensionToken.toLowerCase());
                    }
                }

                if (currentSingleton != Character.MIN_VALUE && currentSingleton != 'x') {
                    if (extensions[currentSingleton - 'a'] != null) {
                        throw new JSRangeErrorException("Duplicate singleton");
                    }
                    if (currentExtensionSequence.length() == 0) {
                        throw new JSRangeErrorException("Empty singleton");
                    }

                    extensions[currentSingleton - 'a'] = currentExtensionSequence.toString();
                }

                for (int ii = 0; ii < 26; ii++) {
                    if (extensions[ii] != null && !extensions[ii].isEmpty())
                        localeBuilder.setExtension((char) ('a' + ii), extensions[ii]);
                }

            }
            ;

        }catch (RuntimeException ex) {
            ex.printStackTrace();
        }

        String canonical = localeBuilder.build().toLanguageTag();
        // return ULocale.forLanguageTag(canonical).toLanguageTag();
        return canonical;
    }

    // https://tc39.es/ecma402/#sec-canonicalizeunicodelocaleid
    // Definition of Canonical Unicode Locale Ids: https://unicode.org/reports/tr35/#Canonical_Unicode_Locale_Identifiers
    private static String canonicalizeUnicodeLocaleId(String locale, StringBuffer languageSubtagBuffer,
                                                      StringBuffer scriptSubtagBuffer, StringBuffer regionSubtagBuffer,
                                                      ArrayList<String> variantSubtagList,
                                                      StringBuffer extensionAndPrivateUseSequenceBuffer) throws JSRangeErrorException{
        String canonical = null;


        // We rely on platform libraries for actual transformation to the canonical form.
        //
        // Starting from Android 7.0 (API level 24), the Android platform exposes a subset of the ICU4J APIs for app developers to use under the android.icu package.
        //
        // Prior to Android 7.0, Android platform uses ICU and CLDR to implement various classes for handling both Latin and non-Latin orthographies,
        // exposing classes like Locale, Character, and many subclasses of java.text.
        // But, forLanguageTag and toLanguageTag methods in java.util.Locale got added in API Level 21
        //
        // For older devices, we take a crude fallback .. assuming that the locale id is already canonicalized.
        //
        // https://tc39.es/ecma402/#sec-canonicalizeunicodelocaleid
        // Steps 1. and 2.

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            canonical = canonicalizeUnicodeLocaleIdUsingPlatformICU(locale, languageSubtagBuffer, scriptSubtagBuffer, regionSubtagBuffer, variantSubtagList, extensionAndPrivateUseSequenceBuffer);
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            canonical = java.util.Locale.forLanguageTag(locale).toLanguageTag();
        } else {
            canonical = locale;
        }

        assert (canonical != null);

        // 3.
        // This step ensures that a Unicode locale extension sequence in the returned language tag contains:
        //
        //    only the first instance of any attribute duplicated in the input, and
        //    only the first keyword for a given key in the input.
        // Note : TODO: We are currently skipping this step ..

        return canonical;
    }

    private static void copyLocaleStringToBufferNormalized(StringBuffer buffer, String locale) throws JSRangeErrorException{
        assert(buffer.length() == 0);

        // Normalize the string by
        // 1. lower casing
        // 2. Convert '_' to - [Nope: We are not doing it as test262 has tests which validates that the separator is hyphen]
        // 3. avoiding leading and trailing whitespaces [Nope; We are not doing it as test262 has tests which validates that the leading and trailing spaces should throw]

        // Seek past initial spaces.
        // int idx=0;
        // while (locale.charAt(idx) == ' ')idx++;
        if(locale.charAt(0) == ' ' || locale.charAt(locale.length()-1) == ' ')
            throw new JSRangeErrorException("Incorrect locale information provided");


        int idx=0;
        for(; idx<locale.length(); idx++) {
            char localeChar = locale.charAt(idx);

            //if(localeChar == '_') {
            //    buffer.append('-');
            //    continue;
            //}

            buffer.append(Character.toLowerCase(localeChar));
        }

        // idx=buffer.length()-1;
        // while (buffer.charAt(idx) == ' ') idx--;
        // buffer.delete(idx+1, buffer.length());
    }

    // Implementation of https://tc39.es/ecma402/#sec-canonicalizelocalelist
    private static List<String> canonicalizeLocaleList(List<String> locales) throws
            JSRangeErrorException {
        // 1. If locales is undefined, then
        // Return a new empty List.
        if (locales.size() == 0) {
            return Collections.emptyList();
        }

        // Note:: Some other major input validation occurs closer to VM in 'normalizeLocales' in JSLib/aIntl.cpp

        // 2. Let seen be a new empty List.
        ArrayList<String> seen = new ArrayList<String>();

        // 3. If Type(locales) is String or Type(locales) is Object and locales has an [[InitializedLocale]] internal slot, then
        // 4. Else
        // We don't yet support Locale object - https://tc39.es/ecma402/#locale-objects
        // As of now, 'locales' can only be a string list/array.
        // 'O' is not a string array of locales

        // 5. Let len be ? ToLength(? Get(O, "length")).
        // 6. Let k be 0.
        // 7. Repeat, while k < len

        for (String locale : locales) {
            // We don't have steps for 7a. 7b. 7c. i-iv  .. as we only allow string arrays here..

            // Smoke validation.
            // Throw RangeError if input locale string is (1) empty (2) non-ASCII string.
            if (locale == null) {
                throw new JSRangeErrorException("Incorrect locale information provided");
            }

            // TODO :: Avoid repeated compilation of regex
            if (!Pattern.compile("\\p{ASCII}*$").matcher(locale).matches()) {
                throw new JSRangeErrorException(String.format("Invalid language tag: %s", locale));
            }

            StringBuffer localeBuffer = new StringBuffer();

            copyLocaleStringToBufferNormalized(localeBuffer, locale);

            if (locale.isEmpty()) {
                throw new JSRangeErrorException("Incorrect locale information provided");
            }

            try {
                Class.forName("com.facebook.hermes.intl.LanguageTagsGenerated");
            } catch (ClassNotFoundException ex){}

            // Handle grandfathered locales
            int grandfatheredIndex = java.util.Arrays.binarySearch(LanguageTagsGenerated.regularGrandfatheredKeys, localeBuffer.toString());
            if(grandfatheredIndex >= 0) {
                localeBuffer.delete(0, localeBuffer.length());
                localeBuffer.append(LanguageTagsGenerated.regularGrandfatheredReplacements[grandfatheredIndex]);
            }

            StringBuffer languageSubtag = new StringBuffer(8);
            StringBuffer scriptSubtag = new StringBuffer(4);
            StringBuffer regionSubtag = new StringBuffer(4);
            ArrayList<String> variantSubtagList = new ArrayList<>();
            StringBuffer extensionAndPrivateUseSequence = new StringBuffer();

            // 7.c.v
            if(!checkStructuralValidityAndReturnParts(localeBuffer, languageSubtag, scriptSubtag, regionSubtag, variantSubtagList, extensionAndPrivateUseSequence)) {
                throw new JSRangeErrorException(String.format("Incorrect locale information provided: %s", locale==null? "null":locale));
            }

            // 7.c.vi
            String canonicalizedTag = canonicalizeUnicodeLocaleId(locale, languageSubtag, scriptSubtag, regionSubtag, variantSubtagList, extensionAndPrivateUseSequence);

            // 7.c.vii
            if (!canonicalizedTag.isEmpty() && !seen.contains(canonicalizedTag)) {
                seen.add(canonicalizedTag);
            }
        }

        return seen;
    }

    // Implementer note: This method corresponds roughly to
    // https://tc39.es/ecma402/#sec-canonicalizelocalelist
    //
    // Also see the implementer notes on DateTimeFormat#DateTimeFormat()
    // for more discussion of locales and CanonicalizeLocaleList.
    public static List<String> getCanonicalLocales(List<String> locales)
            throws JSRangeErrorException {
        try {
            return canonicalizeLocaleList(locales);
        } catch (RuntimeException ex) {
            ex.printStackTrace();
            return null;
        }
    }

    // Implementer note: This method corresponds roughly to
    // https://tc39.es/ecma402/#sup-string.prototype.tolocalelowercase
    public static String toLocaleLowerCase(List<String> locales, String str) {
        return "lowered";
    }

    // Implementer note: This method corresponds roughly to
    // https://tc39.es/ecma402/#sup-string.prototype.tolocaleuppercase
    public static String toLocaleUpperCase(List<String> locales, String str) {
        return "uppered";
    }
}
