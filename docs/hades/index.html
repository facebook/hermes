<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Hermes Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Hermes Blog Atom Feed"><title data-react-helmet="true">The Hades Garbage Collector | Hermes</title><meta data-react-helmet="true" property="og:url" content="https://hermesengine.dev/docs/hades"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="The Hades Garbage Collector | Hermes"><meta data-react-helmet="true" name="description" content="Hades is a garbage collector for Hermes that aims to improve pause times by an"><meta data-react-helmet="true" property="og:description" content="Hades is a garbage collector for Hermes that aims to improve pause times by an"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hermesengine.dev/docs/hades"><link data-react-helmet="true" rel="alternate" href="https://hermesengine.dev/docs/hades" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hermesengine.dev/docs/hades" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.154be723.css">
<link rel="preload" href="/assets/js/runtime~main.8ba2547b.js" as="script">
<link rel="preload" href="/assets/js/main.4baadd0d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><div class="announcementBar_3WsW" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_3EUC">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Hermes</strong></a><a class="navbar__item navbar__link" href="/docs/building-and-running">Docs</a><a class="navbar__item navbar__link" href="/playground/">Playground</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/hermes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Hermes</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/building-and-running">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/playground/">Playground</a></li><li class="menu__list-item"><a href="https://github.com/facebook/hermes" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Documentation</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/building-and-running">Building and Running</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/emscripten">Building with Emscripten</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cross-compilation">Cross Compilation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/language-features">Language Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/intl">Internationalization APIs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/memory-profilers">Memory Profilers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design">Design Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/ir">Design of the IR</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/optimizer">Design of the Optimizer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/vm">VM Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gengc">The GenGC Garbage Collector</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/hades">The Hades Garbage Collector</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/modules">Modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/strings">Strings</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/regexp">RegExp</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Integrations</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/react-native-integration">React Native Integration</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Contributing</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/coding-standards">Coding Standards</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">The Hades Garbage Collector</h1></header><div class="markdown"><p>Hades is a garbage collector for Hermes that aims to improve pause times by an
order of magnitude over GenGC. The main principle Hades uses to achieve those
low pause times is that most of the garbage collection work happens in a
background thread concurrently with the interpreter running JavaScript code.
This is distinct from GenGC, which only runs on a single thread which is shared
with the interpreter.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="enabling-hades"></a>Enabling Hades<a class="hash-link" href="#enabling-hades" title="Direct link to heading">#</a></h1><p>In local builds on the command line using CMake or <code>configure.py</code> (which
forwards to CMake), Hades is the default GC used, and currently the only GC
supported for production use.
The GC being used is controlled by the CMake variable <code>-DHERMESVM_GCKIND=value</code>.</p><p>To use a pre-built package of Hermes with Hades enabled, check the
<a href="https://github.com/facebook/hermes/releases" target="_blank" rel="noopener noreferrer">Releases page on Github</a>.
As of right now, there aren&#x27;t any available, but we&#x27;ll be making one available
with v0.8 and later.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="check-which-gc-is-used"></a>Check Which GC is Used<a class="hash-link" href="#check-which-gc-is-used" title="Direct link to heading">#</a></h2><p>If you want to know what GC is being used in your application, you can find out
with some JS:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly js"><div tabindex="0" class="prism-code language-js codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#FFFFFF;background:#242526"><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token keyword" style="color:#c5a5c5">const</span><span class="token plain"> gcName </span><span class="token operator" style="color:#fc929e">=</span><span class="token plain"> </span><span class="token maybe-class-name">HermesInternal</span><span class="token punctuation" style="color:#657b83">.</span><span class="token method function property-access" style="color:#79b6f2">getRuntimeProperties</span><span class="token punctuation" style="color:#657b83">(</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">.</span><span class="token constant" style="color:#5a9bcf">GC</span><span class="token punctuation" style="color:#657b83">;</span><span class="token plain"></span></div><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// If you&#x27;re running Hermes on the command line, use print.</span><span class="token plain"></span></div><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token function" style="color:#79b6f2">print</span><span class="token punctuation" style="color:#657b83">(</span><span class="token plain">gcName</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">;</span><span class="token plain"></span></div><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// If you&#x27;re running Hermes in some kind of framework like React Native,</span><span class="token plain"></span></div><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// console.log should exist.</span><span class="token plain"></span></div><div class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token console class-name" style="color:#fac863">console</span><span class="token punctuation" style="color:#657b83">.</span><span class="token method function property-access" style="color:#79b6f2">log</span><span class="token punctuation" style="color:#657b83">(</span><span class="token plain">gcName</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This will print one of:</p><ul><li><code>&quot;hades (concurrent)&quot;</code>: You&#x27;re using Hades in concurrent mode</li><li><code>&quot;hades (incremental)&quot;</code>: You&#x27;re using Hades in <a href="#incremental-mode">incremental mode</a></li></ul><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="basics"></a>Basics<a class="hash-link" href="#basics" title="Direct link to heading">#</a></h1><p>Most of the basic heap structure of Hades is similar to GenGC, so it is
recommended to read the <a href="/docs/gengc">GenGC Documentation</a> first, in particular
the following sections:</p><ul><li><a href="/docs/gengc#heap-segments">Heap Segments</a></li><li><a href="/docs/gengc#object-types">Object Types</a></li><li><a href="/docs/gengc#generations">Generations</a></li><li><a href="/docs/gengc#write-barriers">Write Barriers</a></li></ul><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="generations"></a>Generations<a class="hash-link" href="#generations" title="Direct link to heading">#</a></h1><p>Similarly to GenGC, Hades also has two generations: the <strong>Young Generation</strong>
(YG) and <strong>Old Generation</strong> (OG). Allocations go initially into YG, and if they
survive the first collection they go into OG. YG works exactly the same as
GenGC, but OG has a different allocation strategy that allows for gaps.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="freelist-allocator"></a>Freelist Allocator<a class="hash-link" href="#freelist-allocator" title="Direct link to heading">#</a></h2><p>Hades&#x27;s OG is a list of heap segments, and each heap segment maintains a
<strong>Free List</strong> of empty space. Each <strong>Free List Cell</strong> points to the next cell,
called an explicit free list. This is opposed to an implicit free list, where
the length is used to traverse both free and used cells. A free list is used
because it allows empty space to be left where it is, without requiring
compaction. This is a requirement for concurrent allocations and sweeping.</p><p>Furthermore, the free list is <strong>size-segregated</strong>, meaning each size class gets
a separate free list. In other words, cells of size <code>N</code> only point to other
cells of size <code>N</code>. This allows an allocation of size <code>N</code> to be satisfied
instantly with the head of the free list. Each free list head is stored at an
index in a fixed-size array for small cell sizes. These are known as
<strong>buckets</strong>.</p><p>Hades does not do any rounding up of sizes beyond the required heap alignment
of 8 bytes. This means there is one bucket for each multiple of 8, up to 2048
bytes. From 2048 bytes to the maximum heap segment size (4 MiB) the buckets go
by powers of 2. For large buckets, we store cells that are greater than or equal
to the size bucket, but less than the next power of 2. Cells that need less than
the size of the free list cell <strong>carve</strong> out a small piece of the cell, and put
the remaining piece on a the free list corresponding to its new size.</p><p>Due to having these free lists be per-segment, we need a quick way to find which
segment has free space for a given size. We do this with a series of bit arrays,
where bits are flipped to 0 as a free list is exhausted in a segment, and
flipped back to 1 when sweeping frees some cells. We have per-segment free lists
so that sweeping and compaction (which also operate on a per-segment basis) can
destroy them efficiently and create a new list. It can do this to easily
coalesce adjacent free regions.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="collection-cycles"></a>Collection Cycles<a class="hash-link" href="#collection-cycles" title="Direct link to heading">#</a></h1><p>Hades has two different types of collections: a YG collection (YG GC) and an
OG collection (OG GC). The former is almost exactly the same as GenGC&#x27;s, so we
won&#x27;t repeat it here. The OG GC is very different though, because it runs
concurrently in a background thread.</p><p>For the purposes of distinguishing these two threads, we&#x27;ll name them as
follows:</p><ul><li><strong>Mutator Thread</strong>: The thread running the JS interpreter</li><li><strong>GC Thread</strong>: The thread running any GC operations such as marking or
sweeping</li></ul><p>Note that currently there is only ever a single GC thread at any point in time.
We also cache the thread and reuse it instead of making a new one for each
collection.</p><p>There are three different locks used throughout the GC:</p><ul><li>The <strong>GC Mutex</strong> is used to protect structures like mark bits, card tables,
and the free lists</li><li>The <strong>WeakRef Mutex</strong> is used to protect structures used during weak ref
marking</li><li>The <strong>Write Barrier Mutex</strong> is used to protect a small buffer used by write
barriers and concurrent marking</li></ul><p>The GC mutex is used to protect most things, as they tend to all be accessed at
the same time. There was no need for finer grained locks yet, with the exception
of the write barrier mutex because write barriers are executed all the time.</p><p>An OG GC is started once the OG is about 75% full. We start it a bit early so
that it can complete sweeping before reaching 100% full and avoid blocking any
allocations.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="mark-phase"></a>Mark Phase<a class="hash-link" href="#mark-phase" title="Direct link to heading">#</a></h2><p>The first step of an OG GC is to mark all of the roots of the object graph.
We only ever start an OG GC when YG is empty, so there&#x27;s no need to mark any of
YG.</p><p>Marking an object consists of the following steps:</p><ul><li>Using mark bits, check if an object has been visited already</li><li>If it has been visited already, there&#x27;s nothing to do</li><li>If not, push it onto a <strong>mark stack</strong> that will be drained later</li><li>Set its mark bit</li><li>If the object pointed to is a WeakMap, put it onto a separate stack
(see <a href="/docs/gengc#weak-map-resolution">Weak Map Resolution</a>)</li></ul><p>Draining the mark stack works as follows:</p><ul><li>Acquire a lock on the GC mutex</li><li>Check if the write barrier buffer has objects that need to be marked, if so,
add them to the mark stack</li><li>While we&#x27;ve marked fewer than a certain number of bytes, defaults to 8 KiB<ul><li>Pull one object off the mark stack</li><li>Get its type metadata (see <a href="/docs/gengc#object-types">Object Types</a>)</li><li>Use the metadata to find pointers to other objects</li><li>Those other objects will be pushed on the stack</li></ul></li><li>Release the lock on the GC mutex</li></ul><p>This can run almost entirely uninterrupted on the background thread since very
few things need to acquire the GC mutex. The most common way to interrupt
marking is when YG fills up, as it requires the GC mutex in order to evacuate
YG.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="write-barriers"></a>Write Barriers<a class="hash-link" href="#write-barriers" title="Direct link to heading">#</a></h3><p>There&#x27;s an important race condition to consider when thinking about concurrent
marking: what happens if a pointer is modified while we&#x27;re reading it?</p><p>There are two different races that are possible here:</p><ul><li>A non-atomic read of the pointer might race with a non-atomic write, and the
reads or writes might &quot;tear&quot; (meaning you see only part of the write)</li><li>You might miss marking the old value or the new value</li></ul><p>The first is handled on 64-bit platforms because all of the reads are of a 64
bit value, which can be atomically handled cheaply on a 64-bit CPU. See the
<a href="#incremental-mode">Incremental Mode</a> section for what we do on a 32-bit CPU.</p><p>The second problem is harder to solve. If we see the old value, and the new
object isn&#x27;t marked anywhere else, we would accidentally think it&#x27;s garbage and
collect it! Alternatively, if we see the new value, the old value won&#x27;t be
marked. This would be a problem if the old pointer was moved from one object to
another, but we had already marked the second object.</p><p>In order to fix this, we need to know when a pointer is modified during
concurrent marking. Hades implements this through an additional write barrier.
This write barrier is based on a principle called &quot;Snapshot at the Beginning&quot;
(SATB). The principle is that we want to collect the OG based on a snapshot
of the heap when the collection began. Which means if a pointer is changed, we
want to make sure we mark the old value instead of the new value.</p><p>This might feel counter-intuitive compared to the more common alternative
approach known as &quot;Incremental Update&quot; (IU), where the new value is marked. The
reason Hades uses SATB instead is that it has a nice guarantee: you&#x27;ll never
need to revisit any object you have already marked. This means there is a finite
upper bound on the amount of work marking has to do. IU write barrier based
systems often have a race near the end, where the GC thread needs to pause the
mutator thread to try and complete marking as fast as possible. If it exceeds
a time quota, it resumes the mutator and tries again later. We avoid this
complexity with our SATB barrier.</p><p>A second benefit of SATB is that we can treat any allocations made into OG
between the start and end of the collection as alive by default, without
needing to mark them.</p><p>And the final benefit of SATB is that there is never a need to mark the roots
again to finish a collection, as their old values were handled at the start
of the collection while the mutator was paused.</p><p>The barrier works by pushing the old value onto a small fixed size buffer, which
has space for 128 elements. Once it fills up, the Write Barrier Lock is taken to
&quot;flush&quot; the buffer into a separate mark stack used by the concurrent marker.
This means a lock is only taken every 128 write barriers. It uses a separate
mutex from the GC mutex to ensure a write barrier is not blocked for very long
if the GC thread happens to be reading from the separate mark stack.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="complete-marking"></a>Complete Marking<a class="hash-link" href="#complete-marking" title="Direct link to heading">#</a></h2><p>Once the mark stack is empty, there are a few details that need to be handled in
order to complete marking and move on to sweeping:</p><ul><li>Flush any remaining write barrier pointers left</li><li>Handle WeakMap resolution</li><li>Fix weak references (WeakRefs)</li></ul><p>Handling these things can be very tricky concurrently, so in order to prevent
bugs and infinite loops, we pause the mutator during this time. Even though SATB
write barriers don&#x27;t require the mutator to pause, these other operations do
require a pause, so unfortunately this is still required.</p><p>Flushing the remaining write barrier pointers just means copying the pointers
into the mark stack and draining it one more time. This could potentially take
a very long time, but in practice that is exceedingly rare.</p><p>WeakMap resolution is handled in the same way that GenGC handles it. We do this
during a mutator pause mostly because we didn&#x27;t want to rewrite the algorithm
to work in a concurrent context, as it&#x27;s already very complicated on its own.</p><p>Weak References also need to be cleared if they point to something that is
now garbage, and this is much easier to do with the mutator paused. Otherwise
the mutator would need a lock to read a weak reference value. This could be
improved to simply be an atomic operation in the future, but for now this can&#x27;t
be atomic.</p><p>Once that&#x27;s all taken care of, we can move on to sweeping.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="weakref-read-barriers"></a>WeakRef Read Barriers<a class="hash-link" href="#weakref-read-barriers" title="Direct link to heading">#</a></h3><p>There&#x27;s a caveat to mention about WeakRefs and the SATB barrier. If you read a
pointer out of a weak reference and store it in an object on the heap, SATB
won&#x27;t record the change, and the object might not be found reachable. Something
similar can happen if a weak ref is read and placed into a root.</p><p>To fix this, we have WeakRef reads perform a barrier on the pointer being read.
This conservatively assumes the pointer being read is alive. WeakRefs are not
read from that often, so this was deemed an acceptable cost.</p><p>Note that there also weak roots, such as the HiddenClass cache stored in each
CodeBlock. These do not perform a read barrier, specifically because they are
only ever used for comparisons. They never produce a pointer that was otherwise
dead. A possible simplification of this in the future could use a HiddenClass ID
instead of a pointer, as it achieves the same effect without requiring a special
case.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="sweep-phase"></a>Sweep Phase<a class="hash-link" href="#sweep-phase" title="Direct link to heading">#</a></h2><p>Once complete reachability information is known, the OG GC turns off the
SATB barriers. The sweeper iterates over one segment at a time, allowing the
mutator to interleave. This is specifically allowed because the sweeper only
ever modifies garbage objects that aren&#x27;t used, therefore there&#x27;s no races.
It holds the GC mutex to prevent YG from allocating into the OG while it&#x27;s
being swept.</p><p>The process works as follows:</p><ul><li>Acquire a lock on the GC mutex</li><li>Clear one heap segment&#x27;s free list</li><li>Iterate linearly over cells, using the embedded length to skip over live cells</li><li>Check if a cell is new garbage using its type tag</li><li>If it is not new garbage, continue to the next cell</li><li>If it is new garbage, turn it into a free list cell.</li><li>Contiguous unused regions are added as a single region onto the new free list</li><li>Once all cells in the segment have been processed, release the lock</li></ul><p>Once that process is completed for every heap segment, sweeping completes and
the OG collection is over.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="compact-phase"></a>Compact Phase<a class="hash-link" href="#compact-phase" title="Direct link to heading">#</a></h2><p>Compacting live memory to be closer together is still a beneficial concept in
Hades, as it allows us to return unused memory to the OS, and reduces the
fragmentation of the free lists for mostly empty heap segments. Implementing it
is more tricky than GenGC though, as we can&#x27;t modify pointers concurrently with
the mutator thread.</p><p>Due to these restrictions, we can currently only compact a single segment
(called the compactee) for each full collection. Compaction runs as part of the
collection cycle and flows as follows:</p><ol><li>At the start of an OG collection, determine whether the heap is currently
larger than its target size. If so, select and record a segment to compact.</li><li>Write barriers start dirtying cards for pointers pointing into the
compaction candidate. This will continue until the compaction is fully complete.</li><li>Marking begins. During marking, we dirty cards in the card table
corresponding to any on-heap pointers that point into the compaction candidate.
Any YG collection that occurs during marking needs special care. Promoted
objects will not be scanned by the OG since they are allocated as marked, so
they need to be scanned for compactee pointers after they have been promoted.
Furthermore, the card table cannot be cleared at the end of the YG collection,
since that would erase information from the ongoing compaction.</li><li>During the STW pause, the internal state of the GC is updated to signal that
all pointers into the compactee have been marked, and that the next YG
collection should complete the compaction.</li><li>Sweeping. The segment identified for compaction will not be swept, however
compaction may take place during sweeping if the next YG collection starts
before sweeping is complete. Note that write barriers will continue to be active
until compaction is complete, since new pointers from the OG into the compactee
may be added.</li><li>Compaction. The next young gen collection evacuates both the YG and the
compactee. It will mark long lived roots and update pointers based on the
previously dirtied cards. Combining compaction with YG collections lets us
share the overhead of updating roots, and lets us avoid tracking pointers from
the YG into the compactee.</li><li>The now empty segment is released by the GC and returned to the OS.</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="incremental-mode"></a>Incremental Mode<a class="hash-link" href="#incremental-mode" title="Direct link to heading">#</a></h2><p>Hades&#x27;s concurrent marking relies on being able to read a 64-bit value
atomically at the same time it might be modified by the mutator. If the
underlying hardware supports this natively, then we use it.
However, some hardware does not support doing those atomic reads in a lock-free
manner, primarily 32-bit ARM CPUs. Since Hermes&#x27;s main target is mobile devices,
it&#x27;s important for us to still support them, and have some of the fast pause
time guarantees that Hades gives.</p><p>In order to do this, on 32-bit platforms we don&#x27;t use any other threads, and
instead run Hades in &quot;incremental mode&quot;. This means instead of marking objects
concurrently on the GC thread, we use a portion of each YG GC to do some OG GC
work. This means the OG GC is completed incrementally on each individual YG GC.
Each YG GC takes a little bit longer while an OG GC is active, but the penalty
is small enough to still have better guarantees than running a fully blocking OG
GC.</p><p>The concurrent mode of Hades has faster pauses and is preferred to be used if
possible, but incremental mode has to be used on most 32-bit CPUs. You can also
use incremental mode if threads aren&#x27;t supported on your platform, or if you
prefer to not use threads for some other reason.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/facebook/hermes/blob/HEAD/website/../doc/Hades.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-11-03T22:54:30.000Z" class="lastUpdatedDate_1WI_">11/3/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/gengc"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« The GenGC Garbage Collector</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/modules"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Modules Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#check-which-gc-is-used" class="table-of-contents__link">Check Which GC is Used</a></li><li><a href="#freelist-allocator" class="table-of-contents__link">Freelist Allocator</a></li><li><a href="#mark-phase" class="table-of-contents__link">Mark Phase</a><ul><li><a href="#write-barriers" class="table-of-contents__link">Write Barriers</a></li></ul></li><li><a href="#complete-marking" class="table-of-contents__link">Complete Marking</a><ul><li><a href="#weakref-read-barriers" class="table-of-contents__link">WeakRef Read Barriers</a></li></ul></li><li><a href="#sweep-phase" class="table-of-contents__link">Sweep Phase</a></li><li><a href="#compact-phase" class="table-of-contents__link">Compact Phase</a></li><li><a href="#incremental-mode" class="table-of-contents__link">Incremental Mode</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/language-features">Language Features</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/building-and-running">Building and Running</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/emscripten">Building with Emscripten</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Integrations</h4><ul class="footer__items"><li class="footer__item"><a href="https://reactnative.dev/docs/hermes" target="_blank" rel="noopener noreferrer" class="footer__link-item">Using with React Native</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/react-native-integration">Using a custom build with React Native</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/HermesEngine" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li><li class="footer__item"><a href="https://github.com/facebook/hermes" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/cookie-policy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Cookies</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_MyFc"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></a></div><div class="footer__copyright">Copyright Â© 2022 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8ba2547b.js"></script>
<script src="/assets/js/main.4baadd0d.js"></script>
</body>
</html>